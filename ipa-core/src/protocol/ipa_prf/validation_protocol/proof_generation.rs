use futures_util::future::try_join;

use crate::{
    error::Error,
    ff::Fp61BitPrime,
    helpers::Direction,
    protocol::{
        context::{
            dzkp_field::{UVTupleBlock, BLOCK_SIZE},
            Context,
        },
        ipa_prf::malicious_security::{
            lagrange::{CanonicalLagrangeDenominator, LagrangeTable},
            prover::{LargeProofGenerator, SmallProofGenerator, UVValues},
        },
        prss::SharedRandomness,
        RecordId,
    },
    secret_sharing::SharedValue,
};

/// This is a tuple of `ZeroKnowledgeProofs` owned by a verifier.
/// It consists of a proof from the prover on the left
/// and a proof from the prover on the right.
///
/// The first proof has a different length, i.e. length `P`.
/// It is therefore not stored in the vector with the other proofs.
///
/// `ProofsToVerify` also contains two masks `p_0` and `q_0` in `masks` stored as `(p_0,q_0)`
/// These masks are used as additional `u,v` values for the final proof.
/// These masks mask sensitive information when verifying the final proof.
#[derive(Debug)]
pub struct BatchToVerify {
    first_proof_from_left: [Fp61BitPrime; LargeProofGenerator::PROOF_LENGTH],
    first_proof_from_right: [Fp61BitPrime; LargeProofGenerator::PROOF_LENGTH],
    proofs_from_left: Vec<[Fp61BitPrime; SmallProofGenerator::PROOF_LENGTH]>,
    proofs_from_right: Vec<[Fp61BitPrime; SmallProofGenerator::PROOF_LENGTH]>,
    masks: (Fp61BitPrime, Fp61BitPrime),
}

impl BatchToVerify {
    /// This function generates the `BatchToVerify`.
    /// The helper party fist generates its own proof
    /// together with the proof from the left, i.e. `proof_from_left` (via `PRSS`)
    /// It then distributes
    /// shares of the proof to the helper on the left
    /// and
    /// receives a proof from the right helper, i.e. `proof_from_right`.
    pub async fn generate_batch_to_verify<C, I>(ctx: C, uv_tuple_block: I) -> Self
    where
        C: Context,
        I: Iterator<Item = UVTupleBlock<Fp61BitPrime>> + Clone,
    {
        // generate Proof
        let (prover_left_proof, proof_from_left, (p, q)) =
            ProofBatch::compute_proof(&ctx, uv_tuple_block);

        // send prover_left_proof and receive proof_from_right
        let length = prover_left_proof.len();
        let send = prover_left_proof.send_to_left(&ctx);
        let receive = ProofBatch::receive_from_right(&ctx, length);
        let ((), proof_from_right) = try_join(send, receive).await.unwrap();

        // output
        BatchToVerify {
            first_proof_from_left: proof_from_left.first_proof,
            first_proof_from_right: proof_from_right.first_proof,
            proofs_from_left: proof_from_left.proofs,
            proofs_from_right: proof_from_right.proofs,
            masks: (p, q),
        }
    }
}

/// This a `ProofBatch` generated by a prover.
struct ProofBatch {
    first_proof: [Fp61BitPrime; LargeProofGenerator::PROOF_LENGTH],
    proofs: Vec<[Fp61BitPrime; SmallProofGenerator::PROOF_LENGTH]>,
}

impl FromIterator<Fp61BitPrime> for ProofBatch {
    fn from_iter<T: IntoIterator<Item = Fp61BitPrime>>(iter: T) -> Self {
        let mut iterator = iter.into_iter();
        // consume the first P elements
        let first_proof = iterator
            .by_ref()
            .take(LargeProofGenerator::PROOF_LENGTH)
            .collect::<[Fp61BitPrime; LargeProofGenerator::PROOF_LENGTH]>();
        // consume the rest
        let proofs = iterator.collect::<Vec<[Fp61BitPrime; SmallProofGenerator::PROOF_LENGTH]>>();
        ProofBatch {
            first_proof,
            proofs,
        }
    }
}

impl ProofBatch {
    /// This function returns the length in field elements.
    fn len(&self) -> usize {
        self.proofs.len() * SmallProofGenerator::PROOF_LENGTH + LargeProofGenerator::PROOF_LENGTH
    }

    /// This function returns an iterator over the field elements of all proofs.
    fn iter(&self) -> impl Iterator<Item = &Fp61BitPrime> {
        self.first_proof
            .iter()
            .chain(self.proofs.iter().flat_map(|x| x.iter()))
    }

    /// This function sends a `Proof` to the party on the left
    async fn send_to_left<C>(&self, ctx: &C) -> Result<(), Error>
    where
        C: Context,
    {
        // set up context
        let ctx_left = ctx.set_total_records(self.len());

        // set up channel
        let send_channel_left =
            &ctx_left.send_channel::<Fp61BitPrime>(ctx.role().peer(Direction::Left));

        // send to left
        // we send the proof batch via sending the individual field elements
        ctx_left
            .parallel_join(
                self.iter().enumerate().map(|(i, x)| async move {
                    send_channel_left.send(RecordId::from(i), x).await
                }),
            )
            .await?;
        Ok(())
    }

    /// This function receives a `Proof` from the party on the right.
    async fn receive_from_right<C>(ctx: &C, length: usize) -> Result<Self, Error>
    where
        C: Context,
    {
        // set up context
        let ctx_left = ctx.set_total_records(length);

        // set up channel
        let receive_channel_right =
            &ctx_left.recv_channel::<Fp61BitPrime>(ctx.role().peer(Direction::Right));

        // receive from the right
        Ok(ctx
            .parallel_join(
                (0..length)
                    .map(|i| async move { receive_channel_right.receive(RecordId::from(i)).await }),
            )
            .await?
            .into_iter()
            .collect())
    }

    /// This function generates a batch of quadratic proofs
    /// it iteratively generates proofs and collects them in a batch
    ///
    /// It generates `batch_from_left` as its left output
    /// and `prover_left_batch` as its right output.
    /// Further, it outputs the generated masks needed for the verification of proof from the left and right.
    ///
    /// Outputs `(batch_from_left, prover_left_batch, (p_mask, q_mask))`
    ///
    /// ## Panics
    /// Panics when the recursion factor is smaller than 2 or masks cannot be set safely (implementation issue).
    fn compute_proof<C, I>(ctx: &C, uv_tuple_block: I) -> (Self, Self, (Fp61BitPrime, Fp61BitPrime))
    where
        C: Context,
        I: Iterator<Item = UVTupleBlock<Fp61BitPrime>> + Clone,
    {
        // set up record counter
        let mut record_counter = RecordId::from(0);

        // generate first proof from input iterator
        let (mut uv_values, first_proof_from_left, prover_left_first_proof) = {
            // precomputation for first proof
            // first denominator
            let first_denominator = CanonicalLagrangeDenominator::<
                Fp61BitPrime,
                { LargeProofGenerator::RECURSION_FACTOR },
            >::new();
            // first lagrange table
            let first_lagrange_table = LagrangeTable::<
                Fp61BitPrime,
                { LargeProofGenerator::RECURSION_FACTOR },
                { LargeProofGenerator::LAGRANGE_LENGTH },
            >::from(first_denominator);

            LargeProofGenerator::compute_next_proof(
                ctx,
                &mut record_counter,
                &first_lagrange_table,
                Self::polynomials_from_blocks(uv_tuple_block),
            )
        };

        // storage for other proofs
        let mut prover_left_proofs =
            Vec::<[Fp61BitPrime; SmallProofGenerator::PROOF_LENGTH]>::new();
        let mut proofs_from_left = Vec::<[Fp61BitPrime; SmallProofGenerator::PROOF_LENGTH]>::new();

        // precomputation for other proofs
        // denominator
        let denominator = CanonicalLagrangeDenominator::<
            Fp61BitPrime,
            { SmallProofGenerator::RECURSION_FACTOR },
        >::new();
        // lagrange table
        let lagrange_table = LagrangeTable::<
            Fp61BitPrime,
            { SmallProofGenerator::RECURSION_FACTOR },
            { SmallProofGenerator::LAGRANGE_LENGTH },
        >::from(denominator);

        // recursively generate proofs
        // until there are less than `RECURSION_FACTOR * (RECURSION_FACTOR-1)` many (u,v) field elements
        // and then do one more iteration
        // This ensures that after the last iteration,
        // there are at most RECURSION_FACTOR-1 many real (u,v) field elements
        // Therefore at least the last field element is a `F:ZERO` filler that can be replaced
        // Therefore we have space to include the masks during the final proof
        //
        // we remark that uv_store.len() will always be at least 1
        // further, polynomial uv_store.uv[0].0 and .1 will always have
        // RECURSION_FACTOR many points
        // since they are arrays of fixed length, i.e. RECURSION_FACTOR,
        // (which are filled with `F::ZERO` when there are not enough elements).
        let r_minus_one = SmallProofGenerator::RECURSION_FACTOR - 1;
        uv_values = loop {
            let stop = uv_values.len() <= r_minus_one;

            // generate next proof
            let (uv_values_new, proof_from_left, prover_left_proof) =
                SmallProofGenerator::compute_next_proof::<
                    _,
                    _,
                    _,
                    { SmallProofGenerator::RECURSION_FACTOR },
                >(ctx, &mut record_counter, &lagrange_table, uv_values.iter());
            // collect proof
            proofs_from_left.push(proof_from_left);
            prover_left_proofs.push(prover_left_proof);

            uv_values = uv_values_new;

            if stop {
                break uv_values;
            }
        };

        // generate masks
        // verifier on the right has p,
        // therefore the right share is "implicitly sent" to the right ("communicated" via PRSS)
        let (p_mask_from_left, p_mask_prover): (Fp61BitPrime, Fp61BitPrime) =
            ctx.prss().generate_fields(record_counter);
        record_counter += 1;
        // and verifier on the left has q
        // therefore the left share is "implicitly sent" to the left (communication via PRSS)
        let (q_mask_prover, q_mask_from_right): (Fp61BitPrime, Fp61BitPrime) =
            ctx.prss().generate_fields(record_counter);
        record_counter += 1;

        // compute final uv values
        let (u_values, v_values) = &mut uv_values[0];
        // check that last elements are really Zero
        debug_assert_eq!(
            u_values[SmallProofGenerator::RECURSION_FACTOR - 1],
            Fp61BitPrime::ZERO
        );
        debug_assert_eq!(
            v_values[SmallProofGenerator::RECURSION_FACTOR - 1],
            Fp61BitPrime::ZERO
        );
        // shift first element to last position
        u_values[SmallProofGenerator::RECURSION_FACTOR - 1] = u_values[0];
        v_values[SmallProofGenerator::RECURSION_FACTOR - 1] = v_values[0];
        // set masks in first position
        u_values[0] = p_mask_prover;
        v_values[0] = q_mask_prover;

        // generate last proof
        let (_, proof_from_left, prover_left_proof): (
            UVValues<Fp61BitPrime, { SmallProofGenerator::RECURSION_FACTOR }>,
            [Fp61BitPrime; SmallProofGenerator::PROOF_LENGTH],
            [Fp61BitPrime; SmallProofGenerator::PROOF_LENGTH],
        ) = SmallProofGenerator::compute_next_proof(
            ctx,
            &mut record_counter,
            &lagrange_table,
            uv_values.iter(),
        );

        // collect proof
        proofs_from_left.push(proof_from_left);
        prover_left_proofs.push(prover_left_proof);

        // output proofs
        // as well as the "received" masks
        // (which are "communicated" via PRSS)
        // these are later required by the verification
        (
            ProofBatch {
                first_proof: prover_left_first_proof,
                proofs: prover_left_proofs,
            },
            ProofBatch {
                first_proof: first_proof_from_left,
                proofs: proofs_from_left,
            },
            (p_mask_from_left, q_mask_from_right),
        )
    }

    /// This is a helper function that allows to split a `UVTupleBlock`
    /// which consists of arrays of size `BLOCK_SIZE`
    /// into an iterator over arrays of size `LargeProofGenerator::RECURSION_FACTOR`.
    ///
    /// ## Panic
    /// Panics when `unwrap` panics, i.e. `try_from` fails to convert a slice to an array.
    fn polynomials_from_blocks<I>(
        blocks: I,
    ) -> impl Iterator<
        Item = (
            [Fp61BitPrime; LargeProofGenerator::RECURSION_FACTOR],
            [Fp61BitPrime; LargeProofGenerator::RECURSION_FACTOR],
        ),
    > + Clone
    where
        I: Iterator<Item = UVTupleBlock<Fp61BitPrime>> + Clone,
    {
        assert_eq!(BLOCK_SIZE % LargeProofGenerator::RECURSION_FACTOR, 0);
        blocks.flat_map(|(u_block, v_block)| {
            (0usize..(BLOCK_SIZE / LargeProofGenerator::RECURSION_FACTOR)).map(move |i| {
                (
                    <[Fp61BitPrime; LargeProofGenerator::RECURSION_FACTOR]>::try_from(
                        &u_block[i * LargeProofGenerator::RECURSION_FACTOR
                            ..(i + 1) * LargeProofGenerator::RECURSION_FACTOR],
                    )
                    .unwrap(),
                    <[Fp61BitPrime; LargeProofGenerator::RECURSION_FACTOR]>::try_from(
                        &v_block[i * LargeProofGenerator::RECURSION_FACTOR
                            ..(i + 1) * LargeProofGenerator::RECURSION_FACTOR],
                    )
                    .unwrap(),
                )
            })
        })
    }
}

#[cfg(all(test, unit_test))]
mod test {
    use rand::{thread_rng, Rng};

    use crate::{
        ff::{Fp61BitPrime, U128Conversions},
        protocol::{
            context::dzkp_field::BLOCK_SIZE,
            ipa_prf::{
                malicious_security::prover::{LargeProofGenerator, SmallProofGenerator},
                validation_protocol::proof_generation::BatchToVerify,
            },
        },
        secret_sharing::{replicated::ReplicatedSecretSharing, SharedValue},
        test_executor::run,
        test_fixture::{Runner, TestWorld},
    };

    impl Default for Fp61BitPrime {
        fn default() -> Self {
            Fp61BitPrime::ZERO
        }
    }

    #[test]
    fn generate_verifier_batch() {
        run(|| async move {
            let world = TestWorld::default();

            let mut rng = thread_rng();

            // each helper samples a random value h
            // which is later used to generate distinct values across helpers
            let h = Fp61BitPrime::truncate_from(rng.gen_range(0u128..100));

            let result = world
                .semi_honest(h, |ctx, h| async move {
                    let h = Fp61BitPrime::truncate_from(h.left().as_u128() % 100);
                    // generate blocks of UV values
                    // generate u values as (1h,2h,3h,....,10h*BlockSize) split into Blocksize chunks
                    // where BlockSize = 32
                    // v values are identical to u
                    let uv_tuple_vec = (0usize..100)
                        .map(|i| {
                            (
                                (BLOCK_SIZE * i..BLOCK_SIZE * (i + 1))
                                    .map(|j| {
                                        Fp61BitPrime::truncate_from(u128::try_from(j).unwrap()) * h
                                    })
                                    .collect::<[Fp61BitPrime; BLOCK_SIZE]>(),
                                (BLOCK_SIZE * i..BLOCK_SIZE * (i + 1))
                                    .map(|j| {
                                        Fp61BitPrime::truncate_from(u128::try_from(j).unwrap()) * h
                                    })
                                    .collect::<[Fp61BitPrime; BLOCK_SIZE]>(),
                            )
                        })
                        .collect::<Vec<_>>();

                    // generate and output VerifierBatch together with h value
                    (
                        h,
                        BatchToVerify::generate_batch_to_verify(ctx, uv_tuple_vec.into_iter())
                            .await,
                    )
                })
                .await;

            // proof from first party
            simple_proof_check(result[0].0, &result[2].1, &result[1].1);

            // proof from second party
            simple_proof_check(result[1].0, &result[0].1, &result[2].1);

            // proof from third party
            simple_proof_check(result[2].0, &result[1].1, &result[0].1);
        });
    }

    fn simple_proof_check(
        h: Fp61BitPrime,
        left_verifier: &BatchToVerify,
        right_verifier: &BatchToVerify,
    ) {
        // check lengths:
        // first proof has correct length
        assert_eq!(
            left_verifier.first_proof_from_left.len(),
            LargeProofGenerator::PROOF_LENGTH
        );
        assert_eq!(
            left_verifier.first_proof_from_left.len(),
            left_verifier.first_proof_from_right.len()
        );
        // other proofs has correct length
        for i in 0..left_verifier.proofs_from_left.len() {
            assert_eq!(
                (i, left_verifier.proofs_from_left[i].len()),
                (i, SmallProofGenerator::PROOF_LENGTH)
            );
            assert_eq!(
                (i, left_verifier.proofs_from_left[i].len()),
                (i, left_verifier.proofs_from_right[i].len())
            );
        }
        // check that masks are not 0
        assert_ne!(
            (left_verifier.masks.0, right_verifier.masks.1),
            (Fp61BitPrime::ZERO, Fp61BitPrime::ZERO)
        );

        // check first proof,
        // compute simple proof without lagrange interpolated points
        let simple_proof = {
            let block_to_polynomial = BLOCK_SIZE / LargeProofGenerator::RECURSION_FACTOR;
            let simple_proof_uv = (0usize..100 * block_to_polynomial)
                .map(|i| {
                    (
                        (LargeProofGenerator::RECURSION_FACTOR * i
                            ..LargeProofGenerator::RECURSION_FACTOR * (i + 1))
                            .map(|j| Fp61BitPrime::truncate_from(u128::try_from(j).unwrap()) * h)
                            .collect::<[Fp61BitPrime; LargeProofGenerator::RECURSION_FACTOR]>(),
                        (LargeProofGenerator::RECURSION_FACTOR * i
                            ..LargeProofGenerator::RECURSION_FACTOR * (i + 1))
                            .map(|j| Fp61BitPrime::truncate_from(u128::try_from(j).unwrap()) * h)
                            .collect::<[Fp61BitPrime; LargeProofGenerator::RECURSION_FACTOR]>(),
                    )
                })
                .collect::<Vec<(
                    [Fp61BitPrime; LargeProofGenerator::RECURSION_FACTOR],
                    [Fp61BitPrime; LargeProofGenerator::RECURSION_FACTOR],
                )>>();

            simple_proof_uv.iter().fold(
                [Fp61BitPrime::ZERO; LargeProofGenerator::RECURSION_FACTOR],
                |mut acc, (left, right)| {
                    for i in 0..LargeProofGenerator::RECURSION_FACTOR {
                        acc[i] += left[i] * right[i];
                    }
                    acc
                },
            )
        };

        // reconstruct computed proof
        // by adding shares left and right
        let proof_computed = left_verifier
            .first_proof_from_right
            .iter()
            .zip(right_verifier.first_proof_from_left.iter())
            .map(|(&left, &right)| left + right)
            .collect::<Vec<Fp61BitPrime>>();

        // check for consistency
        // only check first R::USIZE field elements
        assert_eq!(
            (h.as_u128(), simple_proof.to_vec()),
            (
                h.as_u128(),
                proof_computed[0..LargeProofGenerator::RECURSION_FACTOR].to_vec()
            )
        );
    }
}
